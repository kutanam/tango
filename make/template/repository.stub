package repository

import (
	"context"

	"github.com/payfazz/go-apt/pkg/fazzdb"
)

// {{model}}RepositoryInterface contract for {{camelModel}} repository
type {{model}}RepositoryInterface interface {
	GetQuery(ctx context.Context) (*fazzdb.Query, error)
	RawSelect(ctx context.Context, sample interface{}, query string, payload ...interface{}) (interface{}, error)
    RawExec(ctx context.Context, query string, payload ...interface{}) (bool, error)
	FindAll(ctx context.Context, conditions []fazzdb.SliceCondition, orders []fazzdb.Order, limit int, offset int) ([]*model.{{model}}, error)
	FindOne(ctx context.Context, conditions []fazzdb.SliceCondition, orders []fazzdb.Order) (*model.{{model}}, error)
	Find(ctx context.Context, id {{idDataType}}) (*model.{{model}}, error)
	Create(ctx context.Context, m fazzdb.ModelInterface) (*{{idDataType}}, error)
	Update(ctx context.Context, m fazzdb.ModelInterface) (bool, error)
	Delete(ctx context.Context, m fazzdb.ModelInterface) (bool, error)
}

// {{camelModel}}Repository handle generic access to database
type {{camelModel}}Repository struct {
	base     fazzrepository.RepositoryInterface
	{{camelModel}} *model.{{model}}
}

// GetQuery get query instance from context
func (r *{{camelModel}}Repository) GetQuery(ctx context.Context) (*fazzdb.Query, error) {
	return r.base.GetQuery(ctx)
}

// RawSelect find data by raw query and payload if there is arguments
func (r *{{camelModel}}Repository) RawSelect(ctx context.Context, sample interface{}, query string, payload ...interface{}) (interface{}, error) {
	return r.base.RawSelect(ctx, sample, query, payload...)
}

// RawExec execute query other than SELECT and return success status of the query
func (r *{{camelModel}}Repository) RawExec(ctx context.Context, query string, payload ...interface{}) (bool, error) {
	return r.base.RawExec(ctx, query, payload...)
}

// FindAll find data by given conditions, order, limit and offset
func (r *{{camelModel}}Repository) FindAll(ctx context.Context, conditions []fazzdb.SliceCondition, orders []fazzdb.Order, limit int, offset int) ([]*model.{{model}}, error) {
	results, err := r.base.FindAll(ctx, conditions, orders, limit, offset)
	if results == nil {
	    return nil, err
	}

	return results.([]*model.{{model}}), err
}

// FindOne find one data by given conditions and orders
func (r *{{camelModel}}Repository) FindOne(ctx context.Context, conditions []fazzdb.SliceCondition, orders []fazzdb.Order) (*model.{{model}}, error) {
	result, err := r.base.FindOne(ctx, conditions, orders)
	if result == nil {
		return nil, err
	}

	return result.(*model.{{model}}), err
}

// Find find data by given id
func (r *{{camelModel}}Repository) Find(ctx context.Context, id {{idDataType}}) (*model.{{model}}, error) {
	result, err := r.base.Find(ctx, id)
	if result == nil {
		return nil, err
	}

	return result.(*model.{{model}}), err
}

// Create insert data by given model
func (r *{{camelModel}}Repository) Create(ctx context.Context, m fazzdb.ModelInterface) (*{{idDataType}}, error) {
	result, err := r.base.Create(ctx, m)
	{{uuid-tag}}
	if nil != err {
        return nil, err
    }

    id := formatter.SliceUint8ToString(result.([]uint8))
    return &id, err
    {{end-uuid-tag}}
    {{non-uuid-tag}}
	return result.(*{{idDataType}}), err
	{{end-non-uuid-tag}}
}

// Update update data by given model
func (r *{{camelModel}}Repository) Update(ctx context.Context, m fazzdb.ModelInterface) (bool, error) {
	return r.base.Update(ctx, m)
}

// Delete delete data by given model
func (r *{{camelModel}}Repository) Delete(ctx context.Context, m fazzdb.ModelInterface) (bool, error) {
	return r.base.Delete(ctx, m)
}

// New{{model}}Repository constructor for {{camelModel}} repository
func New{{model}}Repository() {{model}}RepositoryInterface {
	m := model.{{model}}Model()
	return &{{camelModel}}Repository{
		base: fazzrepository.NewRepository(m),
		{{camelModel}}: m,
	}
}
